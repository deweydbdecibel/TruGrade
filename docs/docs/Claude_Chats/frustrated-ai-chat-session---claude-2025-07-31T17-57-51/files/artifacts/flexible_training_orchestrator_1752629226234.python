#!/usr/bin/env python3
"""
üöÄ Flexible Training Orchestrator - Revolutionary Card Grading
============================================================

Zero hardcoded assumptions. Maximum flexibility. Real training.
"""

import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import uuid
import shutil

from fastapi import FastAPI, WebSocket, UploadFile, File, HTTPException, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from ultralytics import YOLO
import torch
import cv2
import numpy as np

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModelArchitecture(Enum):
    """Model architecture options"""
    YOLO_DETECTION = "yolo_detection"           # Object detection
    YOLO_SEGMENTATION = "yolo_segmentation"     # Instance segmentation
    YOLO_OBB = "yolo_obb"                      # Oriented bounding boxes
    CUSTOM_CNN = "custom_cnn"                   # Custom architecture

class TaskType(Enum):
    """Training task types"""
    BORDER_DETECTION = "border_detection"       # Card boundaries
    CORNER_ANALYSIS = "corner_analysis"         # Corner quality
    EDGE_ANALYSIS = "edge_analysis"             # Edge condition
    SURFACE_ANALYSIS = "surface_analysis"       # Surface defects
    CENTERING_ANALYSIS = "centering_analysis"   # Centering measurement

class CardSide(Enum):
    """Card side specification"""
    FRONT = "front"
    BACK = "back"
    BOTH = "both"

class BorderType(Enum):
    """Border detection types"""
    OUTER_ONLY = "outer_only"                   # Physical card edge
    INNER_ONLY = "inner_only"                   # Design boundary
    DUAL_BORDER = "dual_border"                 # Both borders

@dataclass
class TrainingConfig:
    """Flexible training configuration"""
    # Core Settings
    session_name: str
    architecture: ModelArchitecture
    task_type: TaskType
    card_side: CardSide
    border_type: BorderType
    
    # Model Parameters
    num_classes: int = 2
    image_size: int = 640
    batch_size: int = 16
    epochs: int = 100
    learning_rate: float = 0.001
    
    # Hardware
    device: str = "auto"
    workers: int = 8
    
    # Advanced Options
    use_pretrained: bool = True
    freeze_backbone: bool = False
    augmentation_strength: str = "medium"  # light, medium, heavy
    early_stopping_patience: int = 20
    
    # Output
    save_weights: bool = True
    save_metrics: bool = True
    export_onnx: bool = False

class FlexibleTrainingOrchestrator:
    """Flexible training system with zero hardcoded assumptions"""

    def __init__(self):
        self.app = FastAPI(title="Flexible Training Orchestrator")
        self.setup_cors()
        self.active_sessions = {}
        self.websocket_connections = set()
        self.setup_routes()
        
        logger.info("üéØ Flexible Training Orchestrator initialized")

    def setup_cors(self):
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

    def setup_routes(self):
        @self.app.get("/")
        async def dashboard():
            return HTMLResponse(self.get_dashboard_html())

        @self.app.get("/api/model-architectures")
        async def get_architectures():
            return [
                {
                    "id": arch.value,
                    "name": arch.name.replace("_", " ").title(),
                    "description": self.get_arch_description(arch),
                    "supports_segmentation": arch in [ModelArchitecture.YOLO_SEGMENTATION],
                    "supports_obb": arch in [ModelArchitecture.YOLO_OBB]
                }
                for arch in ModelArchitecture
            ]

        @self.app.get("/api/task-types")
        async def get_task_types():
            return [
                {
                    "id": task.value,
                    "name": task.name.replace("_", " ").title(),
                    "description": self.get_task_description(task),
                    "recommended_classes": self.get_recommended_classes(task)
                }
                for task in TaskType
            ]

        @self.app.post("/api/session/create")
        async def create_session(config_data: Dict):
            """Create flexible training session"""
            
            try:
                config = TrainingConfig(**config_data)
                session_id = str(uuid.uuid4())
                
                # Create session workspace
                workspace = Path(f"/tmp/training_sessions/{session_id}")
                workspace.mkdir(parents=True, exist_ok=True)
                
                # Initialize session
                session = {
                    "id": session_id,
                    "config": config,
                    "workspace": workspace,
                    "status": "created",
                    "images": [],
                    "labels": [],
                    "created_at": datetime.now(),
                    "progress": {"epoch": 0, "total_epochs": config.epochs}
                }
                
                self.active_sessions[session_id] = session
                
                return {
                    "session_id": session_id,
                    "status": "created",
                    "config": config_data,
                    "workspace": str(workspace)
                }
                
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))

        @self.app.post("/api/session/{session_id}/upload-images")
        async def upload_images(
            session_id: str,
            files: List[UploadFile] = File(...)
        ):
            """Upload training images"""
            
            if session_id not in self.active_sessions:
                raise HTTPException(status_code=404, detail="Session not found")
            
            session = self.active_sessions[session_id]
            images_dir = session["workspace"] / "images"
            images_dir.mkdir(exist_ok=True)
            
            uploaded = []
            for file in files:
                if file.content_type.startswith("image/"):
                    file_path = images_dir / file.filename
                    with open(file_path, "wb") as f:
                        content = await file.read()
                        f.write(content)
                    
                    uploaded.append({
                        "filename": file.filename,
                        "path": str(file_path),
                        "size": len(content)
                    })
                    session["images"].append(str(file_path))
            
            return {
                "session_id": session_id,
                "uploaded": len(uploaded),
                "total_images": len(session["images"]),
                "files": uploaded
            }

        @self.app.post("/api/session/{session_id}/upload-labels")
        async def upload_labels(
            session_id: str,
            label_format: str = Form(...),  # "yolo", "coco", "xml"
            files: List[UploadFile] = File(...)
        ):
            """Upload ground truth labels"""
            
            if session_id not in self.active_sessions:
                raise HTTPException(status_code=404, detail="Session not found")
            
            session = self.active_sessions[session_id]
            labels_dir = session["workspace"] / "labels"
            labels_dir.mkdir(exist_ok=True)
            
            uploaded = []
            for file in files:
                file_path = labels_dir / file.filename
                with open(file_path, "wb") as f:
                    content = await file.read()
                    f.write(content)
                
                uploaded.append({
                    "filename": file.filename,
                    "path": str(file_path),
                    "format": label_format
                })
                session["labels"].append(str(file_path))
            
            return {
                "session_id": session_id,
                "uploaded": len(uploaded),
                "total_labels": len(session["labels"]),
                "label_format": label_format,
                "files": uploaded
            }

        @self.app.get("/api/session/{session_id}/validate")
        async def validate_session(session_id: str):
            """Validate training session readiness"""
            
            if session_id not in self.active_sessions:
                raise HTTPException(status_code=404, detail="Session not found")
            
            session = self.active_sessions[session_id]
            
            validation = {
                "session_id": session_id,
                "ready": False,
                "issues": [],
                "warnings": [],
                "summary": {
                    "images": len(session["images"]),
                    "labels": len(session["labels"]),
                    "architecture": session["config"].architecture.value,
                    "task_type": session["config"].task_type.value,
                    "classes": session["config"].num_classes
                }
            }
            
            # Validation logic
            if len(session["images"]) == 0:
                validation["issues"].append("No images uploaded")
            elif len(session["images"]) < 10:
                validation["warnings"].append(f"Only {len(session['images'])} images - recommend 100+ for robust training")
            
            if len(session["labels"]) == 0:
                validation["issues"].append("No labels uploaded")
            elif len(session["labels"]) != len(session["images"]):
                validation["warnings"].append(f"Image/label count mismatch: {len(session['images'])} images, {len(session['labels'])} labels")
            
            if len(validation["issues"]) == 0:
                validation["ready"] = True
            
            return validation

        @self.app.post("/api/session/{session_id}/start-training")
        async def start_training(session_id: str):
            """Start real YOLO training"""
            
            if session_id not in self.active_sessions:
                raise HTTPException(status_code=404, detail="Session not found")
            
            session = self.active_sessions[session_id]
            session["status"] = "training"
            
            # Start training in background
            asyncio.create_task(self.run_real_training(session_id))
            
            return {
                "session_id": session_id,
                "status": "training_started",
                "message": "Real YOLO training started with progress tracking"
            }

        @self.app.get("/api/session/{session_id}/progress")
        async def get_progress(session_id: str):
            """Get training progress"""
            
            if session_id not in self.active_sessions:
                raise HTTPException(status_code=404, detail="Session not found")
            
            session = self.active_sessions[session_id]
            return session.get("progress", {"epoch": 0, "status": "not_started"})

        @self.app.websocket("/ws/{session_id}")
        async def websocket_endpoint(websocket: WebSocket, session_id: str):
            """WebSocket for real-time progress"""
            
            await websocket.accept()
            self.websocket_connections.add(websocket)
            
            try:
                while True:
                    await websocket.receive_text()
            except:
                self.websocket_connections.discard(websocket)

    async def run_real_training(self, session_id: str):
        """Real YOLO training implementation"""
        
        try:
            session = self.active_sessions[session_id]
            config = session["config"]
            workspace = session["workspace"]
            
            await self.broadcast_progress(session_id, {
                "status": "preparing",
                "message": "Preparing dataset...",
                "epoch": 0,
                "total_epochs": config.epochs
            })
            
            # Prepare YOLO dataset
            dataset_yaml = await self.prepare_yolo_dataset(session)
            
            if not dataset_yaml:
                raise Exception("Failed to prepare dataset")
            
            # Initialize model based on architecture
            model = self.initialize_model(config)
            
            await self.broadcast_progress(session_id, {
                "status": "training",
                "message": f"Starting {config.architecture.value} training...",
                "epoch": 0,
                "total_epochs": config.epochs
            })
            
            # Training parameters
            train_args = {
                "data": str(dataset_yaml),
                "epochs": config.epochs,
                "batch": config.batch_size,
                "imgsz": config.image_size,
                "lr0": config.learning_rate,
                "device": "cpu" if config.device == "cpu" else 0,
                "workers": config.workers,
                "project": str(workspace),
                "name": f"training_{session_id[:8]}",
                "exist_ok": True,
                "patience": config.early_stopping_patience,
                "save_period": 5,
                "verbose": True
            }
            
            # Add architecture-specific parameters
            if config.architecture == ModelArchitecture.YOLO_SEGMENTATION:
                train_args["task"] = "segment"
            elif config.architecture == ModelArchitecture.YOLO_OBB:
                train_args["task"] = "obb"
            
            # Custom progress callback
            def on_epoch_end(trainer):
                epoch = trainer.epoch + 1
                metrics = trainer.metrics if hasattr(trainer, 'metrics') else {}
                
                progress_data = {
                    "status": "training",
                    "epoch": epoch,
                    "total_epochs": config.epochs,
                    "loss": float(metrics.get('train/box_loss', 0)),
                    "precision": float(metrics.get('metrics/precision', 0)),
                    "recall": float(metrics.get('metrics/recall', 0)),
                    "mAP50": float(metrics.get('metrics/mAP50', 0))
                }
                
                # Update session
                session["progress"] = progress_data
                
                # Broadcast to WebSocket clients
                asyncio.create_task(self.broadcast_progress(session_id, progress_data))
            
            # Override callback
            model.add_callback('on_train_epoch_end', on_epoch_end)
            
            # Start training
            logger.info(f"üöÄ Starting real training: {config.architecture.value}")
            results = model.train(**train_args)
            
            # Training completed
            final_metrics = {
                "status": "completed",
                "message": "Training completed successfully!",
                "epoch": config.epochs,
                "total_epochs": config.epochs,
                "final_mAP": float(results.results_dict.get('metrics/mAP50', 0))
            }
            
            session["progress"] = final_metrics
            await self.broadcast_progress(session_id, final_metrics)
            
            # Save model if requested
            if config.save_weights:
                weights_dir = workspace / f"training_{session_id[:8]}" / "weights"
                if (weights_dir / "best.pt").exists():
                    final_model = workspace / f"model_{config.task_type.value}.pt"
                    shutil.copy2(weights_dir / "best.pt", final_model)
                    logger.info(f"‚úÖ Model saved: {final_model}")
            
            session["status"] = "completed"
            logger.info(f"‚úÖ Training completed: {session_id}")
            
        except Exception as e:
            logger.error(f"‚ùå Training failed: {e}")
            
            error_data = {
                "status": "error",
                "message": f"Training failed: {str(e)}",
                "epoch": session.get("progress", {}).get("epoch", 0)
            }
            
            session["progress"] = error_data
            session["status"] = "failed"
            await self.broadcast_progress(session_id, error_data)

    def initialize_model(self, config: TrainingConfig) -> YOLO:
        """Initialize model based on configuration"""
        
        if config.architecture == ModelArchitecture.YOLO_DETECTION:
            if config.use_pretrained:
                model = YOLO("yolo11n.pt")
            else:
                model = YOLO("yolo11n.yaml")
        elif config.architecture == ModelArchitecture.YOLO_SEGMENTATION:
            if config.use_pretrained:
                model = YOLO("yolo11n-seg.pt")
            else:
                model = YOLO("yolo11n-seg.yaml")
        elif config.architecture == ModelArchitecture.YOLO_OBB:
            if config.use_pretrained:
                model = YOLO("yolo11n-obb.pt")
            else:
                model = YOLO("yolo11n-obb.yaml")
        else:
            # Default to detection
            model = YOLO("yolo11n.pt")
        
        return model

    async def prepare_yolo_dataset(self, session: Dict) -> Optional[Path]:
        """Prepare YOLO dataset from uploaded files"""
        
        try:
            workspace = session["workspace"]
            config = session["config"]
            
            # Create YOLO structure
            yolo_dir = workspace / "yolo_dataset"
            (yolo_dir / "images" / "train").mkdir(parents=True, exist_ok=True)
            (yolo_dir / "images" / "val").mkdir(parents=True, exist_ok=True)
            (yolo_dir / "labels" / "train").mkdir(parents=True, exist_ok=True)
            (yolo_dir / "labels" / "val").mkdir(parents=True, exist_ok=True)
            
            # Get files
            images = session["images"]
            labels = session["labels"]
            
            # Simple 80/20 split
            split_idx = int(0.8 * len(images))
            train_images = images[:split_idx]
            val_images = images[split_idx:]
            train_labels = labels[:split_idx]
            val_labels = labels[split_idx:]
            
            # Copy files
            for img, lbl in zip(train_images, train_labels):
                shutil.copy2(img, yolo_dir / "images" / "train" / Path(img).name)
                shutil.copy2(lbl, yolo_dir / "labels" / "train" / Path(lbl).name)
            
            for img, lbl in zip(val_images, val_labels):
                shutil.copy2(img, yolo_dir / "images" / "val" / Path(img).name)
                shutil.copy2(lbl, yolo_dir / "labels" / "val" / Path(lbl).name)
            
            # Create dataset.yaml
            class_names = self.generate_class_names(config)
            dataset_yaml = yolo_dir / "dataset.yaml"
            
            yaml_content = f"""# Flexible Training Dataset
# Generated: {datetime.now().isoformat()}
# Task: {config.task_type.value}
# Architecture: {config.architecture.value}

path: {yolo_dir}
train: images/train
val: images/val

nc: {config.num_classes}
names: {class_names}
"""
            
            with open(dataset_yaml, 'w') as f:
                f.write(yaml_content)
            
            logger.info(f"‚úÖ Dataset prepared: {len(train_images)} train, {len(val_images)} val")
            return dataset_yaml
            
        except Exception as e:
            logger.error(f"‚ùå Dataset preparation failed: {e}")
            return None

    def generate_class_names(self, config: TrainingConfig) -> List[str]:
        """Generate class names based on task and border type"""
        
        if config.task_type == TaskType.BORDER_DETECTION:
            if config.border_type == BorderType.OUTER_ONLY:
                return ["outer_border"]
            elif config.border_type == BorderType.INNER_ONLY:
                return ["inner_border"]
            elif config.border_type == BorderType.DUAL_BORDER:
                return ["outer_border", "inner_border"]
        
        elif config.task_type == TaskType.CORNER_ANALYSIS:
            return ["top_left", "top_right", "bottom_left", "bottom_right"]
        
        elif config.task_type == TaskType.EDGE_ANALYSIS:
            return ["top_edge", "right_edge", "bottom_edge", "left_edge"]
        
        elif config.task_type == TaskType.SURFACE_ANALYSIS:
            return ["scratch", "dent", "stain", "print_defect"]
        
        # Default
        return [f"class_{i}" for i in range(config.num_classes)]

    async def broadcast_progress(self, session_id: str, data: Dict):
        """Broadcast progress to WebSocket clients"""
        
        message = json.dumps({
            "session_id": session_id,
            "timestamp": datetime.now().isoformat(),
            **data
        })
        
        disconnected = set()
        for websocket in self.websocket_connections:
            try:
                await websocket.send_text(message)
            except:
                disconnected.add(websocket)
        
        # Remove disconnected clients
        self.websocket_connections -= disconnected

    def get_arch_description(self, arch: ModelArchitecture) -> str:
        descriptions = {
            ModelArchitecture.YOLO_DETECTION: "Object detection with bounding boxes",
            ModelArchitecture.YOLO_SEGMENTATION: "Instance segmentation with pixel masks",
            ModelArchitecture.YOLO_OBB: "Oriented bounding boxes for rotated objects",
            ModelArchitecture.CUSTOM_CNN: "Custom convolutional neural network"
        }
        return descriptions.get(arch, "Advanced computer vision model")

    def get_task_description(self, task: TaskType) -> str:
        descriptions = {
            TaskType.BORDER_DETECTION: "Detect card borders and boundaries",
            TaskType.CORNER_ANALYSIS: "Analyze corner quality and damage",
            TaskType.EDGE_ANALYSIS: "Evaluate edge condition and wear",
            TaskType.SURFACE_ANALYSIS: "Detect surface defects and scratches",
            TaskType.CENTERING_ANALYSIS: "Measure card centering accuracy"
        }
        return descriptions.get(task, "Computer vision analysis task")

    def get_recommended_classes(self, task: TaskType) -> int:
        recommendations = {
            TaskType.BORDER_DETECTION: 2,
            TaskType.CORNER_ANALYSIS: 4,
            TaskType.EDGE_ANALYSIS: 4,
            TaskType.SURFACE_ANALYSIS: 3,
            TaskType.CENTERING_ANALYSIS: 1
        }
        return recommendations.get(task, 2)

    def get_dashboard_html(self) -> str:
        return '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>üéØ Flexible Training Orchestrator</title>
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: 'Segoe UI', system-ui, sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh; color: #333;
                }
                .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
                .header {
                    background: rgba(255,255,255,0.95); border-radius: 20px;
                    padding: 40px; text-align: center; margin-bottom: 30px;
                }
                .config-grid {
                    display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px; margin: 20px 0;
                }
                .config-section {
                    background: rgba(255,255,255,0.95); border-radius: 15px;
                    padding: 25px;
                }
                .form-group { margin: 15px 0; }
                .form-group label { display: block; margin-bottom: 5px; font-weight: 500; }
                .form-group select, .form-group input {
                    width: 100%; padding: 10px; border: 2px solid #e0e6ff;
                    border-radius: 8px; font-size: 14px;
                }
                .btn {
                    background: #4ecdc4; color: white; padding: 15px 30px;
                    border: none; border-radius: 8px; cursor: pointer;
                    font-size: 16px; margin: 10px 5px;
                }
                .btn:hover { background: #45b7b8; }
                .upload-zone {
                    border: 3px dashed #4ecdc4; border-radius: 15px;
                    padding: 40px; text-align: center; margin: 20px 0;
                    background: rgba(255,255,255,0.1);
                }
                .progress-container {
                    background: rgba(255,255,255,0.95); border-radius: 15px;
                    padding: 25px; margin: 20px 0; display: none;
                }
                .progress-bar {
                    background: #e0e6ff; height: 30px; border-radius: 15px;
                    overflow: hidden; margin: 15px 0;
                }
                .progress-fill {
                    background: linear-gradient(45deg, #4ecdc4, #44a08d);
                    height: 100%; width: 0%; transition: width 0.3s;
                    display: flex; align-items: center; justify-content: center;
                    color: white; font-weight: bold;
                }
                .metrics-grid {
                    display: grid; grid-template-columns: repeat(4, 1fr);
                    gap: 15px; margin: 20px 0;
                }
                .metric {
                    background: #f8f9ff; padding: 15px; border-radius: 10px;
                    text-align: center;
                }
                .metric-value {
                    font-size: 1.5em; font-weight: bold; color: #4ecdc4;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üéØ Flexible Training Orchestrator</h1>
                    <p>Zero Hardcoded Assumptions ‚Ä¢ Maximum Control ‚Ä¢ Real Training</p>
                </div>

                <div class="config-grid">
                    <!-- Model Configuration -->
                    <div class="config-section">
                        <h3>üèóÔ∏è Model Architecture</h3>
                        <div class="form-group">
                            <label>Architecture Type</label>
                            <select id="architecture">
                                <option value="yolo_detection">YOLO Detection</option>
                                <option value="yolo_segmentation">YOLO Segmentation</option>
                                <option value="yolo_obb">YOLO Oriented Boxes</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Task Type</label>
                            <select id="task_type">
                                <option value="border_detection">Border Detection</option>
                                <option value="corner_analysis">Corner Analysis</option>
                                <option value="edge_analysis">Edge Analysis</option>
                                <option value="surface_analysis">Surface Analysis</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Border Type</label>
                            <select id="border_type">
                                <option value="outer_only">Outer Only</option>
                                <option value="inner_only">Inner Only</option>
                                <option value="dual_border">Dual Border</option>
                            </select>
                        </div>
                    </div>

                    <!-- Training Configuration -->
                    <div class="config-section">
                        <h3>‚öôÔ∏è Training Parameters</h3>
                        <div class="form-group">
                            <label>Session Name</label>
                            <input type="text" id="session_name" placeholder="Border Detection Model">
                        </div>
                        <div class="form-group">
                            <label>Number of Classes</label>
                            <input type="number" id="num_classes" value="2" min="1" max="10">
                        </div>
                        <div class="form-group">
                            <label>Epochs</label>
                            <input type="number" id="epochs" value="100" min="10" max="1000">
                        </div>
                        <div class="form-group">
                            <label>Batch Size</label>
                            <select id="batch_size">
                                <option value="8">8 (Low Memory)</option>
                                <option value="16" selected>16 (Recommended)</option>
                                <option value="32">32 (High Memory)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Hardware Configuration -->
                    <div class="config-section">
                        <h3>üñ•Ô∏è Hardware Settings</h3>
                        <div class="form-group">
                            <label>Device</label>
                            <select id="device">
                                <option value="auto">Auto Detect</option>
                                <option value="cpu">CPU Only</option>
                                <option value="gpu">GPU (CUDA)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Workers</label>
                            <input type="number" id="workers" value="8" min="1" max="16">
                        </div>
                        <div class="form-group">
                            <label>Image Size</label>
                            <select id="image_size">
                                <option value="416">416px</option>
                                <option value="512">512px</option>
                                <option value="640" selected>640px</option>
                                <option value="800">800px</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div style="text-align: center; margin: 30px 0;">
                    <button class="btn" onclick="createSession()">üöÄ Create Training Session</button>
                </div>

                <!-- Session Management -->
                <div id="session-panel" style="display: none;">
                    <div class="config-grid">
                        <!-- Image Upload -->
                        <div class="config-section">
                            <h3>üì∑ Upload Images</h3>
                            <div class="upload-zone" onclick="document.getElementById('image-files').click()">
                                <p>Click to upload training images</p>
                                <p>Supports: JPG, PNG, JPEG</p>
                            </div>
                            <input type="file" id="image-files" multiple accept="image/*" style="display: none;" onchange="uploadImages()">
                            <div id="image-status"></div>
                        </div>

                        <!-- Label Upload -->
                        <div class="config-section">
                            <h3>üìù Upload Labels</h3>
                            <div class="form-group">
                                <label>Label Format</label>
                                <select id="label_format">
                                    <option value="yolo">YOLO TXT</option>
                                    <option value="coco">COCO JSON</option>
                                    <option value="xml">Pascal VOC XML</option>
                                </select>
                            </div>
                            <div class="upload-zone" onclick="document.getElementById('label-files').click()">
                                <p>Click to upload ground truth labels</p>
                            </div>
                            <input type="file" id="label-files" multiple accept=".txt,.json,.xml" style="display: none;" onchange="uploadLabels()">
                            <div id="label-status"></div>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 30px 0;">
                        <button class="btn" onclick="validateSession()">‚úÖ Validate Session</button>
                        <button class="btn" onclick="startTraining()" id="start-btn" disabled>üöÄ Start Training</button>
                    </div>
                </div>

                <!-- Progress Tracking -->
                <div class="progress-container" id="progress-panel">
                    <h3>üìä Training Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill">0%</div>
                    </div>
                    <div id="progress-text">Initializing...</div>
                    <div class="metrics-grid" id="metrics-grid"></div>
                </div>
            </div>

            <script>
                let currentSessionId = null;
                let trainingSocket = null;

                async function createSession() {
                    const config = {
                        session_name: document.getElementById('session_name').value || 'Border Detection Model',
                        architecture: document.getElementById('architecture').value,
                        task_type: document.getElementById('task_type').value,
                        card_side: 'front',
                        border_type: document.getElementById('border_type').value,
                        num_classes: parseInt(document.getElementById('num_classes').value),
                        epochs: parseInt(document.getElementById('epochs').value),
                        batch_size: parseInt(document.getElementById('batch_size').value),
                        device: document.getElementById('device').value,
                        workers: parseInt(document.getElementById('workers').value),
                        image_size: parseInt(document.getElementById('image_size').value)
                    };

                    try {
                        const response = await fetch('/api/session/create', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(config)
                        });

                        const result = await response.json();
                        if (response.ok) {
                            currentSessionId = result.session_id;
                            document.getElementById('session-panel').style.display = 'block';
                            alert(`‚úÖ Session created: ${result.session_id}`);
                        } else {
                            alert(`‚ùå Error: ${result.detail}`);
                        }
                    } catch (error) {
                        alert(`‚ùå Error: ${error.message}`);
                    }
                }

                async function uploadImages() {
                    if (!currentSessionId) return;

                    const files = document.getElementById('image-files').files;
                    const formData = new FormData();
                    
                    for (let file of files) {
                        formData.append('files', file);
                    }

                    try {
                        const response = await fetch(`/api/session/${currentSessionId}/upload-images`, {
                            method: 'POST',
                            body: formData
                        });

                        const result = await response.json();
                        document.getElementById('image-status').innerHTML = 
                            `‚úÖ ${result.uploaded} images uploaded (${result.total_images} total)`;
                    } catch (error) {
                        alert(`Upload error: ${error.message}`);
                    }
                }

                async function uploadLabels() {
                    if (!currentSessionId) return;

                    const files = document.getElementById('label-files').files;
                    const format = document.getElementById('label_format').value;
                    const formData = new FormData();
                    
                    formData.append('label_format', format);
                    for (let file of files) {
                        formData.append('files', file);
                    }

                    try {
                        const response = await fetch(`/api/session/${currentSessionId}/upload-labels`, {
                            method: 'POST',
                            body: formData
                        });

                        const result = await response.json();
                        document.getElementById('label-status').innerHTML = 
                            `‚úÖ ${result.uploaded} labels uploaded (${result.label_format} format)`;
                    } catch (error) {
                        alert(`Upload error: ${error.message}`);
                    }
                }

                async function validateSession() {
                    if (!currentSessionId) return;

                    try {
                        const response = await fetch(`/api/session/${currentSessionId}/validate`);
                        const result = await response.json();

                        if (result.ready) {
                            document.getElementById('start-btn').disabled = false;
                            alert('‚úÖ Session validated and ready for training!');
                        } else {
                            alert(`‚ùå Issues found: ${result.issues.join(', ')}`);
                        }
                    } catch (error) {
                        alert(`Validation error: ${error.message}`);
                    }
                }

                async function startTraining() {
                    if (!currentSessionId) return;

                    try {
                        const response = await fetch(`/api/session/${currentSessionId}/start-training`, {
                            method: 'POST'
                        });

                        const result = await response.json();
                        if (response.ok) {
                            document.getElementById('progress-panel').style.display = 'block';
                            connectWebSocket();
                            alert('üöÄ Real YOLO training started!');
                        } else {
                            alert(`‚ùå Error: ${result.detail}`);
                        }
                    } catch (error) {
                        alert(`Training error: ${error.message}`);
                    }
                }

                function connectWebSocket() {
                    if (!currentSessionId) return;

                    const wsUrl = `ws://localhost:8010/ws/${currentSessionId}`;
                    trainingSocket = new WebSocket(wsUrl);

                    trainingSocket.onmessage = function(event) {
                        const data = JSON.parse(event.data);
                        updateProgress(data);
                    };

                    trainingSocket.onerror = function(error) {
                        console.error('WebSocket error:', error);
                    };
                }

                function updateProgress(data) {
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');
                    const metricsGrid = document.getElementById('metrics-grid');

                    const progress = (data.epoch / data.total_epochs) * 100;
                    progressFill.style.width = progress + '%';
                    progressFill.textContent = progress.toFixed(1) + '%';

                    progressText.textContent = `${data.status} - Epoch ${data.epoch}/${data.total_epochs}`;

                    if (data.loss !== undefined) {
                        metricsGrid.innerHTML = `
                            <div class="metric">
                                <div class="metric-value">${data.loss.toFixed(4)}</div>
                                <div>Loss</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${(data.precision || 0).toFixed(3)}</div>
                                <div>Precision</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${(data.recall || 0).toFixed(3)}</div>
                                <div>Recall</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${(data.mAP50 || 0).toFixed(3)}</div>
                                <div>mAP50</div>
                            </div>
                        `;
                    }

                    if (data.status === 'completed') {
                        alert('üéâ Training completed successfully!');
                    } else if (data.status === 'error') {
                        alert(`‚ùå Training failed: ${data.message}`);
                    }
                }
            </script>
        </body>
        </html>
        '''

# Main entry point
async def main():
    orchestrator = FlexibleTrainingOrchestrator()
    
    import uvicorn
    config = uvicorn.Config(
        orchestrator.app,
        host="0.0.0.0",
        port=8010,
        log_level="info"
    )
    server = uvicorn.Server(config)
    
    print("üéØ Flexible Training Orchestrator")
    print("=" * 50)
    print("‚úÖ Zero hardcoded assumptions")
    print("üèóÔ∏è Multiple architectures: YOLO Detection/Segmentation/OBB")
    print("üéõÔ∏è Configurable: 1-class to multi-class")
    print("üì± Front/Back card support")
    print("üîÑ Real YOLO training with progress tracking")
    print("üåê Interface: http://localhost:8010")
    print("=" * 50)
    
    await server.serve()

if __name__ == "__main__":
    asyncio.run(main())
