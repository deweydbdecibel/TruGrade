# revolutionary_border_calibration.py
"""
üéØ REVOLUTIONARY BORDER CALIBRATION MODULE
========================================

This is the precision foundation that feeds your revolutionary photometric stereo engine.
Surgical border detection accuracy ‚Üí Microscopic 3D surface analysis ‚Üí Revolutionary grading

Features:
- Integrated YOLO model loading and inference
- Interactive precision border correction with corner anchors
- JSON batch processing for training data management
- Revolutionary UI styling matching your theme system
- Direct pipeline integration to photometric stereo engine
- Real-time confidence scoring and validation
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import customtkinter as ctk
import cv2
import numpy as np
from PIL import Image, ImageTk, ImageDraw
import json
import os
from pathlib import Path
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import threading
import time

# Revolutionary Theme System (copy the classes from revolutionary_shell.py)
class RevolutionaryTheme:
    """Ultra-premium theme system for revolutionary card grader"""

    # REVOLUTIONARY COLOR PALETTE - Future-Forward
    VOID_BLACK = "#0A0A0B"           # Deep space background
    QUANTUM_DARK = "#141519"         # Primary dark surfaces
    NEURAL_GRAY = "#1C1E26"          # Secondary surfaces
    GHOST_WHITE = "#F8F9FA"          # Primary text
    PLASMA_BLUE = "#00D4FF"          # Revolutionary accent
    NEON_CYAN = "#00F5FF"            # Active states
    ELECTRIC_PURPLE = "#8B5CF6"      # Premium features
    QUANTUM_GREEN = "#00FF88"        # Success/Analysis
    PLASMA_ORANGE = "#FF6B35"        # Alerts/Warnings
    GOLD_ELITE = "#FFD700"           # Premium grades

    # TYPOGRAPHY - Future-Ready
    FONT_FAMILY = "SF Pro Display"   # Apple's premium font
    FONT_FAMILY_FALLBACK = "Segoe UI"

    # ANIMATIONS & EFFECTS
    ANIMATION_SPEED = 150
    GLOW_INTENSITY = 15
    BLUR_RADIUS = 20

class RevolutionaryButton(ctk.CTkButton):
    """Ultra-premium button with revolutionary styling"""

    def __init__(self, parent, text="", icon=None, style="primary", **kwargs):

        # Revolutionary button styles
        styles = {
            "primary": {
                "fg_color": RevolutionaryTheme.PLASMA_BLUE,
                "hover_color": RevolutionaryTheme.NEON_CYAN,
                "text_color": RevolutionaryTheme.VOID_BLACK,
                "border_width": 0,
                "corner_radius": 12,
                "font": (RevolutionaryTheme.FONT_FAMILY_FALLBACK, 14, "bold")
            },
            "glass": {
                "fg_color": ("gray20", "gray20"),
                "hover_color": ("gray15", "gray15"),
                "text_color": RevolutionaryTheme.GHOST_WHITE,
                "border_width": 1,
                "border_color": RevolutionaryTheme.PLASMA_BLUE,
                "corner_radius": 16,
                "font": (RevolutionaryTheme.FONT_FAMILY_FALLBACK, 13, "normal")
            },
            "premium": {
                "fg_color": RevolutionaryTheme.ELECTRIC_PURPLE,
                "hover_color": "#9D5CFF",
                "text_color": RevolutionaryTheme.GHOST_WHITE,
                "border_width": 0,
                "corner_radius": 20,
                "font": (RevolutionaryTheme.FONT_FAMILY_FALLBACK, 16, "bold")
            }
        }

        config = styles.get(style, styles["primary"])

        # Set defaults if not provided
        if 'width' not in kwargs:
            kwargs['width'] = 200
        if 'height' not in kwargs:
            kwargs['height'] = 45

        super().__init__(
            parent,
            text=text,
            **config,
            **kwargs
        )

        # Add hover effects
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _on_enter(self, event=None):
        """Revolutionary hover enter effect - NO SIZE CHANGES"""
        # Only change cursor, no dimension changes to prevent wiggling
        pass

    def _on_leave(self, event=None):
        """Revolutionary hover leave effect - NO SIZE CHANGES"""
        # Only change cursor, no dimension changes to prevent wiggling
        pass

try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO_AVAILABLE = False

@dataclass
class BorderAnnotation:
    """Revolutionary border annotation with metadata"""
    x1: float
    y1: float
    x2: float
    y2: float
    class_id: int
    confidence: float
    label: str
    corrected_by_human: bool = False
    correction_timestamp: str = ""
    validation_score: float = 0.0

    @property
    def center_x(self) -> float:
        return (self.x1 + self.x2) / 2

    @property
    def center_y(self) -> float:
        return (self.y1 + self.y2) / 2

    @property
    def width(self) -> float:
        return abs(self.x2 - self.x1)

    @property
    def height(self) -> float:
        return abs(self.y2 - self.y1)

    def contains_point(self, x: float, y: float) -> bool:
        """Check if point is inside the border"""
        return (min(self.x1, self.x2) <= x <= max(self.x1, self.x2) and
                min(self.y1, self.y2) <= y <= max(self.y1, self.y2))

    def get_corner_handle(self, x: float, y: float, handle_size: float = 15) -> Optional[str]:
        """PRECISION - Smaller click area to match visual handles"""
        # üîß PRECISION: Reduced default handle_size from 30 to 15
        left = min(self.x1, self.x2)
        right = max(self.x1, self.x2)
        top = min(self.y1, self.y2)
        bottom = max(self.y1, self.y2)

        print(f"üîç Precision corner check: click({x:.1f}, {y:.1f}) vs box({left:.1f}, {top:.1f}, {right:.1f}, {bottom:.1f})")

        corners = {
            'top_left': (left, top),
            'top_right': (right, top),
            'bottom_left': (left, bottom),
            'bottom_right': (right, bottom)
        }

        for corner_name, (cx, cy) in corners.items():
            distance = ((x - cx)**2 + (y - cy)**2)**0.5
            print(f"  üéØ {corner_name}: ({cx:.1f}, {cy:.1f}) distance: {distance:.1f}")

            if distance <= handle_size:
                print(f"‚úÖ PRECISION CORNER HIT: {corner_name}")
                return corner_name

        print(f"‚ùå No corner hit")
        return None

    def move_corner(self, corner: str, new_x: float, new_y: float):
        """Move a specific corner - WORKING VERSION"""
        print(f"üìç Moving {corner} corner to ({new_x:.1f}, {new_y:.1f})")

        if corner == 'top_left':
            self.x1, self.y1 = new_x, new_y
        elif corner == 'top_right':
            self.x2, self.y1 = new_x, new_y
        elif corner == 'bottom_left':
            self.x1, self.y2 = new_x, new_y
        elif corner == 'bottom_right':
            self.x2, self.y2 = new_x, new_y
        else:
            print(f"‚ùå Unknown corner: {corner}")
            return

        # Mark as corrected
        self.corrected_by_human = True
        self.correction_timestamp = datetime.now().isoformat()
        print(f"‚úÖ Corner {corner} moved successfully")

    def move_border(self, dx: float, dy: float):
        """Move entire border - WORKING VERSION"""
        print(f"üì¶ Moving border by ({dx:.1f}, {dy:.1f})")
        self.x1 += dx
        self.y1 += dy
        self.x2 += dx
        self.y2 += dy

        # Mark as corrected
        self.corrected_by_human = True
        self.correction_timestamp = datetime.now().isoformat()
        print(f"‚úÖ Border moved successfully")

    def to_yolo_format(self, img_width: int, img_height: int) -> str:
        """Convert to YOLO format for retraining"""
        center_x = self.center_x / img_width
        center_y = self.center_y / img_height
        width = self.width / img_width
        height = self.height / img_height
        return f"{self.class_id} {center_x:.6f} {center_y:.6f} {width:.6f} {height:.6f}"

@dataclass
class CalibrationDataset:
    """Revolutionary dataset management for border calibration"""
    name: str
    created: str
    total_images: int
    classes: Dict[int, str]
    annotations: Dict[str, Dict]
    statistics: Dict[str, float]

    def add_image_annotations(self, image_path: str, annotations: List[BorderAnnotation],
                            original_predictions: List[BorderAnnotation] = None):
        """Add annotations for an image"""
        image_name = os.path.basename(image_path)

        self.annotations[image_name] = {
            'image_path': image_path,
            'annotations': [asdict(ann) for ann in annotations],
            'original_predictions': [asdict(pred) for pred in (original_predictions or [])],
            'correction_metadata': {
                'total_corrections': sum(1 for ann in annotations if ann.corrected_by_human),
                'last_modified': datetime.now().isoformat(),
                'validation_status': 'corrected' if any(ann.corrected_by_human for ann in annotations) else 'original'
            }
        }

    def save_to_json(self, filepath: str):
        """Save dataset to JSON file"""
        with open(filepath, 'w') as f:
            json.dump(asdict(self), f, indent=2)

    @classmethod
    def load_from_json(cls, filepath: str):
        """Load dataset from JSON file"""
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls(**data)

class RevolutionaryBorderCalibration(ctk.CTkFrame):
    """üéØ Revolutionary Border Calibration Interface"""

    def __init__(self, parent, command_callback=None, photometric_callback=None):
        super().__init__(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=0
        )

        self.command_callback = command_callback
        self.photometric_callback = photometric_callback

        # Revolutionary model and data management
        self.model = None
        self.model_path = None
        self.current_dataset = None

        # Image management
        self.current_image_path = None
        self.original_image = None
        self.display_image = None
        self.image_files = []
        self.current_index = 0

        # Border annotations
        self.annotations: List[BorderAnnotation] = []
        self.original_predictions: List[BorderAnnotation] = []
        self.selected_annotation: Optional[BorderAnnotation] = None

        # Interactive state
        self.sticky_selection_mode = False
        self.sticky_class_id = None
        self.dragging_corner = None
        self.dragging_border = False
        self.last_mouse_x = 0
        self.last_mouse_y = 0

        # Display settings
        self.zoom_level = 0.5  # 50% default for 600dpi precision
        self.rotation_angle = 0.0
        self.image_scale = 1.0

        # Revolutionary class configuration
        self.class_names = {0: "outer_border", 1: "inner_border"}
        self.class_colors = {
            0: RevolutionaryTheme.PLASMA_BLUE,   # Outer border
            1: RevolutionaryTheme.QUANTUM_GREEN  # Inner border
        }

        self.setup_revolutionary_ui()

        # üîß ADD: Focus and key bindings for shortcuts
        self.focus_set()  # Enable keyboard focus
        self.bind("<KeyPress>", self.on_key_press)
        self.bind("<space>", self.spacebar_next_image)  # Spacebar shortcut

        print("‚å®Ô∏è Keyboard shortcuts enabled!")
        print("   SPACEBAR = Next image + Auto-detect")
        print("   DELETE = Delete selected border")
        print("   1 = Select outer border")
        print("   2 = Select inner border")

    def auto_detect_on_load(self):
        """Automatically run YOLO detection when image loads"""
        if not self.model:
            print("‚ö†Ô∏è No model loaded - skipping auto-detect")
            return

        # Small delay to ensure image is fully loaded
        self.after(100, self.run_revolutionary_detection)
        print("‚ö° AUTO-DETECT triggered!")

    def spacebar_next_image(self, event=None):
        """SPACEBAR shortcut for next image + auto-detect"""
        print("‚å®Ô∏è SPACEBAR pressed - Next image + Auto-detect!")
        self.next_image()
        return "break"  # Prevent event propagation

    def next_image(self):
        """Go to next image with AUTO-DETECT"""
        if self.image_files and self.current_index < len(self.image_files) - 1:
            self.current_index += 1
            self.load_current_image()
            self.update_image_counter()

            # üöÄ AUTO-DETECT on new image
            self.auto_detect_on_load()

            print(f"‚ñ∂ Next: {self.current_index + 1}/{len(self.image_files)} + AUTO-DETECT")

    def prev_image(self):
        """Go to previous image with AUTO-DETECT"""
        if self.image_files and self.current_index > 0:
            self.current_index -= 1
            self.load_current_image()
            self.update_image_counter()

            # üöÄ AUTO-DETECT on new image
            self.auto_detect_on_load()

            print(f"‚óÄ Previous: {self.current_index + 1}/{len(self.image_files)} + AUTO-DETECT")

    def on_key_press(self, event):
        """Enhanced keyboard shortcuts for rapid workflow"""
        key = event.keysym.lower()

        print(f"‚å®Ô∏è Key pressed: {key}")

        if key == 'space':
            # Spacebar = Next image + Auto-detect
            self.spacebar_next_image(event)

        elif key == 'delete' and self.selected_annotation:
            # Delete selected annotation
            self.annotations.remove(self.selected_annotation)
            self.selected_annotation = None
            self.update_selected_info()
            self.draw_annotations()
            print("üóëÔ∏è Deleted selected border")

        elif key == '1':
            # Select outer border
            self.select_border_by_class(0)
            print("üîµ Selected outer border")

        elif key == '2':
            # Select inner border
            self.select_border_by_class(1)
            print("üü¢ Selected inner border")

        elif key == 'r':
            # Reset/rerun detection
            self.run_revolutionary_detection()
            print("üîÑ Re-running detection")

        elif key == 'f':
            # Fit to window
            self.fit_to_window()
            print("üìê Fit to window")

        elif key == 's' and event.state & 0x4:  # Ctrl+S
            # Save dataset
            self.save_dataset()
            print("üíæ Save dataset (Ctrl+S)")

        elif key == 'left':
            # Left arrow = Previous image
            self.prev_image()

        elif key == 'right':
            # Right arrow = Next image
            self.next_image()

    def load_current_image(self):
        """Load image and maintain keyboard focus"""
        if not self.image_files or self.current_index >= len(self.image_files):
            return

        image_path = self.image_files[self.current_index]
        self.current_image_path = image_path

        try:
            # Load with OpenCV
            self.original_image = cv2.imread(image_path)
            if self.original_image is None:
                raise ValueError(f"Could not load image: {image_path}")

            # Display the image
            self.display_current_image()

            # Clear previous annotations
            self.annotations = []
            self.original_predictions = []

            # Maintain focus for shortcuts
            self.after(50, lambda: self.focus_set())

            print(f"üì∏ Loaded: {os.path.basename(image_path)}")

        except Exception as e:
            print(f"‚ùå Error loading image: {e}")

    def run_revolutionary_detection(self):
        """Enhanced detection with auto-selection"""
        if not self.model:
            print("‚ùå No model loaded!")
            return

        if self.original_image is None:
            print("‚ùå No image loaded!")
            return

        print("‚ö° Running AUTO-DETECTION...")

        try:
            # Run inference
            results = self.model(self.original_image, conf=self.confidence_var.get())

            # Clear previous annotations
            self.annotations = []
            self.original_predictions = []

            # Process results
            for result in results:
                boxes = result.boxes
                if boxes is not None:
                    for box in boxes:
                        # Get detection data
                        x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                        conf = box.conf[0].cpu().numpy()
                        cls = int(box.cls[0].cpu().numpy())

                        # Create annotation
                        label = self.class_names.get(cls, f"class_{cls}")
                        annotation = BorderAnnotation(
                            x1=float(x1), y1=float(y1),
                            x2=float(x2), y2=float(y2),
                            class_id=cls,
                            confidence=float(conf),
                            label=label
                        )

                        self.annotations.append(annotation)
                        self.original_predictions.append(annotation)

            # Update display
            self.draw_annotations()

            print(f"‚úÖ AUTO-DETECTION complete: {len(self.annotations)} borders found")

            # Auto-select first border for quick editing
            if self.annotations:
                self.selected_annotation = self.annotations[0]
                self.update_selected_info()
                self.draw_annotations()
                print(f"üéØ Auto-selected: {self.selected_annotation.label}")

        except Exception as e:
            print(f"‚ùå Detection error: {e}")

    def save_dataset(self):
        """Save current dataset with all corrections"""
        print("üíæ Saving dataset with corrections...")

        if not hasattr(self, 'current_dataset') or not self.current_dataset:
            print("‚ùå No dataset to save!")
            return

        # Save dialog
        from tkinter import filedialog
        save_path = filedialog.asksaveasfilename(
            title="Save Corrected Dataset",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if save_path:
            try:
                self.current_dataset.save_to_json(save_path)
                print(f"‚úÖ Dataset saved: {save_path}")
            except Exception as e:
                print(f"‚ùå Save error: {e}")

    def export_json(self):
        """Export corrections as JSON"""
        print("üìÑ Exporting JSON format...")

    def export_yolo_format(self):
        """Export corrections as YOLO format for retraining"""
        print("ü§ñ Exporting YOLO format for retraining...")

    def setup_revolutionary_ui(self):
        """Setup revolutionary calibration interface"""

        # Configure grid weights for responsive layout
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=0)  # Control panel
        self.grid_columnconfigure(1, weight=1)  # Canvas area

        # Revolutionary header
        self.setup_header()

        # Main content area
        self.setup_main_content()

    def setup_header(self):
        """Revolutionary header with branding"""
        header_frame = ctk.CTkFrame(
            self,
            fg_color=RevolutionaryTheme.NEURAL_GRAY,
            corner_radius=0,
            height=80
        )
        header_frame.grid(row=0, column=0, columnspan=2, sticky="ew")
        header_frame.grid_propagate(False)

        # Header content
        title_label = ctk.CTkLabel(
            header_frame,
            text="üéØ REVOLUTIONARY BORDER CALIBRATION",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 28, "bold"),
            text_color=RevolutionaryTheme.PLASMA_BLUE
        )
        title_label.pack(side="left", padx=30, pady=25)

        # Status indicator
        self.status_indicator = ctk.CTkLabel(
            header_frame,
            text="üî¥ NO MODEL LOADED",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 14, "bold"),
            text_color=RevolutionaryTheme.PLASMA_ORANGE
        )
        self.status_indicator.pack(side="right", padx=30, pady=25)

    def setup_main_content(self):
        """Setup main content with control panel and canvas"""

        # Left control panel
        self.setup_control_panel()

        # Right canvas area
        self.setup_canvas_area()

    def add_manual_scroll_buttons(self, parent, scrollable_frame):
        """Add manual scroll buttons as backup"""

        scroll_controls = ctk.CTkFrame(parent, fg_color="transparent", height=30)
        scroll_controls.pack(fill="x", pady=(0, 5))

        def scroll_up():
            try:
                canvas = scrollable_frame._parent_canvas
                if canvas:
                    canvas.yview_scroll(-5, "units")
                    print("‚¨ÜÔ∏è Manual scroll up")
            except:
                pass

        def scroll_down():
            try:
                canvas = scrollable_frame._parent_canvas
                if canvas:
                    canvas.yview_scroll(5, "units")
                    print("‚¨áÔ∏è Manual scroll down")
            except:
                pass

        up_btn = ctk.CTkButton(scroll_controls, text="‚ñ≤", width=30, height=20, command=scroll_up)
        up_btn.pack(side="left", padx=(0, 5))

        down_btn = ctk.CTkButton(scroll_controls, text="‚ñº", width=30, height=20, command=scroll_down)
        down_btn.pack(side="left")

        print("üîò Manual scroll buttons added!")

    def setup_control_panel(self):
        """NUCLEAR FIX - Direct tkinter scroll override"""

        control_panel = ctk.CTkFrame(
            self,
            fg_color=RevolutionaryTheme.NEURAL_GRAY,
            corner_radius=16,
            width=420
        )
        control_panel.grid(row=1, column=0, sticky="nsew", padx=(10, 5), pady=10)
        control_panel.grid_propagate(False)

        # Scrollable content
        scrollable_frame = ctk.CTkScrollableFrame(
            control_panel,
            fg_color="transparent"
        )
        scrollable_frame.pack(fill="both", expand=True, padx=12, pady=12)

        # üîß IMMEDIATE SCROLL: Bind right after creation
        def nuclear_scroll(event):
            """FIXED - Correct scroll direction"""
            try:
                canvas = scrollable_frame._parent_canvas
                if canvas:
                    # üîß FIXED: Inverted the logic
                    if event.delta > 0:
                        # Mouse wheel UP = scroll UP (negative)
                        canvas.yview_scroll(-3, "units")
                        print("‚¨ÜÔ∏è Scroll UP")
                    else:
                        # Mouse wheel DOWN = scroll DOWN (positive)
                        canvas.yview_scroll(3, "units")
                        print("‚¨áÔ∏è Scroll DOWN")

                    return "break"

            except Exception as e:
                print(f"üí• Scroll error: {e}")

            # Method 2: Fallback - direct yview manipulation
            try:
                canvas = scrollable_frame._parent_canvas
                if canvas:
                    top, bottom = canvas.yview()
                    if event.delta > 0:
                        new_top = max(0, top - 0.05)
                    else:
                        new_top = min(1, top + 0.05)
                    canvas.yview_moveto(new_top)
                    print(f"üöÄ FALLBACK SCROLL: {new_top}")
                    return "break"
            except:
                pass

        def bind_everywhere():
            """Bind scroll to every possible widget"""
            widgets_to_bind = [
                scrollable_frame,
                control_panel,
                self,
                scrollable_frame._parent_canvas if hasattr(scrollable_frame, '_parent_canvas') else None
            ]

            for widget in widgets_to_bind:
                if widget:
                    try:
                        # Unbind first to avoid conflicts
                        widget.unbind("<MouseWheel>")
                        widget.unbind("<Button-4>")
                        widget.unbind("<Button-5>")

                        # Bind with high priority
                        widget.bind("<MouseWheel>", nuclear_scroll)
                        widget.bind("<Button-4>", nuclear_scroll)  # Linux
                        widget.bind("<Button-5>", nuclear_scroll)  # Linux
                        print(f"üî´ Nuclear bound to: {widget}")
                    except Exception as e:
                        print(f"‚ùå Binding failed for {widget}: {e}")

        bind_everywhere()
        self.after(200, bind_everywhere)  # Double-bind for safety

        print("üí• NUCLEAR SCROLL DEPLOYED!")

        # Setup sections
        self.setup_model_section(scrollable_frame)
        self.setup_dataset_section(scrollable_frame)
        self.setup_detection_section(scrollable_frame)
        self.setup_editing_section(scrollable_frame)
        self.setup_view_section(scrollable_frame)
        self.setup_pipeline_section(scrollable_frame)

        # At the end, if nuclear scroll fails:
        self.add_manual_scroll_buttons(control_panel, scrollable_frame)

    def setup_model_section(self, parent):
        """YOLO model management with WIDER buttons"""
        model_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=12
        )
        model_frame.pack(fill="x", pady=(0, 15))

        section_title = ctk.CTkLabel(
            model_frame,
            text="ü§ñ YOLO MODEL",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 16, "bold"),
            text_color=RevolutionaryTheme.PLASMA_BLUE
        )
        section_title.pack(pady=(15, 10))

        # Load model button - WIDER
        load_model_btn = RevolutionaryButton(
            model_frame,
            text="üìÇ LOAD MODEL",
            style="primary",
            width=320,  # üîß INCREASED from 250 to 320
            height=40,
            command=self.load_model_dialog
        )
        load_model_btn.pack(pady=(0, 10))

        # Model status - WIDER TEXT
        self.model_status_label = ctk.CTkLabel(
            model_frame,
            text="No model loaded",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11),
            text_color=RevolutionaryTheme.GHOST_WHITE,
            wraplength=320  # üîß INCREASED from 250 to 320
        )
        self.model_status_label.pack(pady=(0, 15))

    def setup_dataset_section(self, parent):
        """Revolutionary dataset management with VISIBLE SAVE BUTTON"""
        dataset_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=12
        )
        dataset_frame.pack(fill="x", pady=(0, 12))

        section_title = ctk.CTkLabel(
            dataset_frame,
            text="üìÅ DATASET MANAGEMENT",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 15, "bold"),
            text_color=RevolutionaryTheme.QUANTUM_GREEN
        )
        section_title.pack(pady=(12, 8))

        # Load images button - FULL WIDTH
        load_images_btn = RevolutionaryButton(
            dataset_frame,
            text="üì∏ LOAD IMAGES",
            style="primary",
            width=370,
            height=38,
            command=self.load_images_dialog
        )
        load_images_btn.pack(pady=(0, 8))

        # Navigation controls
        nav_frame = ctk.CTkFrame(dataset_frame, fg_color="transparent")
        nav_frame.pack(fill="x", padx=12, pady=(0, 8))

        prev_btn = RevolutionaryButton(
            nav_frame,
            text="‚óÄ",
            style="glass",
            width=45,
            height=32,
            command=self.prev_image
        )
        prev_btn.pack(side="left")

        self.image_counter_label = ctk.CTkLabel(
            nav_frame,
            text="No images",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11),
            text_color=RevolutionaryTheme.GHOST_WHITE,
            wraplength=200
        )
        self.image_counter_label.pack(side="left", expand=True, padx=8)

        next_btn = RevolutionaryButton(
            nav_frame,
            text="‚ñ∂",
            style="glass",
            width=45,
            height=32,
            command=self.next_image
        )
        next_btn.pack(side="right")

        # üîß FIXED: Stacked buttons for MAXIMUM VISIBILITY
        dataset_actions_frame = ctk.CTkFrame(dataset_frame, fg_color="transparent")
        dataset_actions_frame.pack(fill="x", padx=12, pady=(0, 12))

        # New dataset button - FULL WIDTH
        new_dataset_btn = RevolutionaryButton(
            dataset_actions_frame,
            text="üìã NEW DATASET",
            style="glass",
            width=350,  # Full width
            height=35,
            command=self.create_new_dataset
        )
        new_dataset_btn.pack(pady=(0, 5))

        # üîß SAVE BUTTON - FULL WIDTH & PROMINENT
        save_dataset_btn = RevolutionaryButton(
            dataset_actions_frame,
            text="üíæ SAVE DATASET",
            style="primary",  # Primary style for visibility
            width=350,  # Full width
            height=40,   # Slightly taller
            command=self.save_dataset
        )
        save_dataset_btn.pack(pady=(0, 5))

        # Export options - ALSO VISIBLE
        export_frame = ctk.CTkFrame(dataset_frame, fg_color="transparent")
        export_frame.pack(fill="x", padx=12, pady=(0, 12))

        export_json_btn = RevolutionaryButton(
            export_frame,
            text="üìÑ EXPORT JSON",
            style="glass",
            width=170,
            height=32,
            command=self.export_json
        )
        export_json_btn.pack(side="left", padx=(0, 8))

        export_yolo_btn = RevolutionaryButton(
            export_frame,
            text="ü§ñ EXPORT YOLO",
            style="glass",
            width=170,
            height=32,
            command=self.export_yolo_format
        )
        export_yolo_btn.pack(side="right")

    def setup_detection_section(self, parent):
        """Detection and calibration controls"""
        detection_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=12
        )
        detection_frame.pack(fill="x", pady=(0, 15))

        section_title = ctk.CTkLabel(
            detection_frame,
            text="üéØ DETECTION & CALIBRATION",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 16, "bold"),
            text_color=RevolutionaryTheme.NEON_CYAN
        )
        section_title.pack(pady=(15, 10))

        # Run detection button
        detect_btn = RevolutionaryButton(
            detection_frame,
            text="‚ö° RUN YOLO DETECTION",
            style="primary",
            width=250,
            height=45,
            command=self.run_revolutionary_detection
        )
        detect_btn.pack(pady=(0, 15))

        # Confidence control
        conf_label = ctk.CTkLabel(
            detection_frame,
            text="üéöÔ∏è Confidence Threshold:",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 12, "bold"),
            text_color=RevolutionaryTheme.GHOST_WHITE
        )
        conf_label.pack(anchor="w", padx=15)

        self.confidence_var = ctk.DoubleVar(value=0.25)
        confidence_slider = ctk.CTkSlider(
            detection_frame,
            from_=0.01,
            to=0.95,
            variable=self.confidence_var,
            width=220
        )
        confidence_slider.pack(pady=(5, 10))

        self.confidence_label = ctk.CTkLabel(
            detection_frame,
            textvariable=self.confidence_var,
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11),
            text_color=RevolutionaryTheme.GHOST_WHITE
        )
        self.confidence_label.pack(pady=(0, 15))

    def setup_editing_section(self, parent):
        """Precision editing controls with FULL TEXT VISIBLE"""
        editing_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=12
        )
        editing_frame.pack(fill="x", pady=(0, 12))

        section_title = ctk.CTkLabel(
            editing_frame,
            text="‚úèÔ∏è PRECISION EDITING",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 15, "bold"),
            text_color=RevolutionaryTheme.ELECTRIC_PURPLE
        )
        section_title.pack(pady=(12, 8))

        # Selected border info
        self.selected_info = ctk.CTkLabel(
            editing_frame,
            text="No border selected",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11),
            text_color=RevolutionaryTheme.GHOST_WHITE,
            wraplength=370
        )
        self.selected_info.pack(pady=(0, 8))

        # üîß FIX: Stacked button layout to ensure full text visibility
        self.outer_btn = RevolutionaryButton(
            editing_frame,
            text="üîµ OUTER BORDER",  # üîß Full text
            style="glass",
            width=350,  # üîß Full width
            height=35,
            command=lambda: self.set_sticky_selection(0)
        )
        self.outer_btn.pack(pady=(0, 5))

        self.inner_btn = RevolutionaryButton(
            editing_frame,
            text="üü¢ INNER BORDER",  # üîß Full text
            style="glass",
            width=350,  # üîß Full width
            height=35,
            command=lambda: self.set_sticky_selection(1)
        )
        self.inner_btn.pack(pady=(0, 8))

        # Stop selection button
        stop_selection_btn = RevolutionaryButton(
            editing_frame,
            text="‚èπÔ∏è STOP SELECTION",
            style="glass",
            width=350,
            height=32,
            command=self.stop_sticky_selection
        )
        stop_selection_btn.pack(pady=(0, 8))

        # Rotation control - COMPACT
        rotation_label = ctk.CTkLabel(
            editing_frame,
            text="üîÑ Fine Rotation (¬±5¬∞):",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11, "bold"),
            text_color=RevolutionaryTheme.GHOST_WHITE
        )
        rotation_label.pack(anchor="w", padx=15, pady=(8, 3))

        rotation_frame = ctk.CTkFrame(editing_frame, fg_color="transparent")
        rotation_frame.pack(fill="x", padx=15, pady=(0, 12))

        self.rotation_var = ctk.DoubleVar()
        rotation_slider = ctk.CTkSlider(
            rotation_frame,
            from_=-5,
            to=5,
            variable=self.rotation_var,
            width=260,
            command=self.update_rotation
        )
        rotation_slider.pack(side="left", fill="x", expand=True)

        reset_rotation_btn = RevolutionaryButton(
            rotation_frame,
            text="‚Ü∫",
            style="glass",
            width=35,
            height=25,
            command=self.reset_rotation
        )
        reset_rotation_btn.pack(side="right", padx=(8, 0))

    def setup_view_section(self, parent):
        """View and zoom controls"""
        view_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.QUANTUM_DARK,
            corner_radius=12
        )
        view_frame.pack(fill="x", pady=(0, 15))

        section_title = ctk.CTkLabel(
            view_frame,
            text="üîç VIEW CONTROLS",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 16, "bold"),
            text_color=RevolutionaryTheme.PLASMA_ORANGE
        )
        section_title.pack(pady=(15, 10))

        # Zoom buttons
        zoom_frame = ctk.CTkFrame(view_frame, fg_color="transparent")
        zoom_frame.pack(fill="x", padx=15, pady=(0, 15))

        zoom_25_btn = RevolutionaryButton(
            zoom_frame,
            text="25%",
            style="glass",
            width=55,
            height=30,
            command=lambda: self.set_zoom(0.25)
        )
        zoom_25_btn.pack(side="left")

        zoom_50_btn = RevolutionaryButton(
            zoom_frame,
            text="50%",
            style="glass",
            width=55,
            height=30,
            command=lambda: self.set_zoom(0.5)
        )
        zoom_50_btn.pack(side="left", padx=5)

        zoom_100_btn = RevolutionaryButton(
            zoom_frame,
            text="100%",
            style="glass",
            width=55,
            height=30,
            command=lambda: self.set_zoom(1.0)
        )
        zoom_100_btn.pack(side="left")

        fit_btn = RevolutionaryButton(
            zoom_frame,
            text="FIT",
            style="glass",
            width=55,
            height=30,
            command=self.fit_to_window
        )
        fit_btn.pack(side="right")

    def setup_pipeline_section(self, parent):
        """Revolutionary pipeline integration"""
        pipeline_frame = ctk.CTkFrame(
            parent,
            fg_color=RevolutionaryTheme.ELECTRIC_PURPLE,
            corner_radius=12,
            border_width=2,
            border_color=RevolutionaryTheme.GOLD_ELITE
        )
        pipeline_frame.pack(fill="x", pady=(0, 15))

        section_title = ctk.CTkLabel(
            pipeline_frame,
            text="üöÄ REVOLUTIONARY PIPELINE",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 16, "bold"),
            text_color=RevolutionaryTheme.GOLD_ELITE
        )
        section_title.pack(pady=(15, 10))

        # Pipeline status
        pipeline_status = ctk.CTkLabel(
            pipeline_frame,
            text="Borders calibrated ‚Üí Ready for photometric stereo",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 11),
            text_color=RevolutionaryTheme.GHOST_WHITE,
            wraplength=250
        )
        pipeline_status.pack(pady=(0, 10))

        # Send to photometric stereo
        photometric_btn = RevolutionaryButton(
            pipeline_frame,
            text="üî¨ SEND TO PHOTOMETRIC STEREO",
            style="premium",
            width=250,
            height=50,
            command=self.send_to_photometric_stereo
        )
        photometric_btn.pack(pady=(0, 15))

    def setup_canvas_area(self):
        """Revolutionary canvas with CustomTkinter compatible scrolling"""
        canvas_frame = ctk.CTkFrame(
            self,
            fg_color=RevolutionaryTheme.VOID_BLACK,
            corner_radius=16
        )
        canvas_frame.grid(row=1, column=1, sticky="nsew", padx=(5, 10), pady=10)

        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)

        # Canvas with scrollbars
        self.canvas = tk.Canvas(
            canvas_frame,
            bg=RevolutionaryTheme.VOID_BLACK,
            highlightthickness=0,
            scrollregion=(0, 0, 1000, 1000)
        )

        # Scrollbars
        v_scrollbar = ctk.CTkScrollbar(
            canvas_frame,
            orientation="vertical",
            command=self.canvas.yview
        )
        h_scrollbar = ctk.CTkScrollbar(
            canvas_frame,
            orientation="horizontal",
            command=self.canvas.xview
        )

        self.canvas.configure(
            yscrollcommand=v_scrollbar.set,
            xscrollcommand=h_scrollbar.set
        )

        # Grid scrollbars and canvas
        self.canvas.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")

        # üîß ADD MOUSE WHEEL SCROLLING
        def on_canvas_wheel(event):
            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

        def on_canvas_shift_wheel(event):
            self.canvas.xview_scroll(int(-1 * (event.delta / 120)), "units")

        # Bind directly to canvas only
        self.canvas.bind("<MouseWheel>", on_canvas_wheel)
        self.canvas.bind("<Shift-MouseWheel>", on_canvas_shift_wheel)

        # Mouse events for border editing
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        self.canvas.bind("<B1-Motion>", self.on_canvas_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_canvas_release)
        self.canvas.bind("<Motion>", self.on_canvas_motion)
        self.canvas.bind("<Key>", self.on_key_press)
        self.canvas.focus_set()

        # Welcome message
        self.show_welcome_message()

    def show_welcome_message(self):
        """Show revolutionary welcome message"""
        welcome_text = self.canvas.create_text(
            400, 300,
            text="üéØ REVOLUTIONARY BORDER CALIBRATION\n\nLoad your YOLO model and images to begin\nprecision border calibration for photometric stereo analysis",
            font=(RevolutionaryTheme.FONT_FAMILY_FALLBACK, 18, "bold"),
            fill=RevolutionaryTheme.PLASMA_BLUE,
            justify="center"
        )

    # Placeholder methods for the interface (implement these as needed)
    def load_model_dialog(self):
        """Load YOLO model - WORKING VERSION"""
        print("ü§ñ Opening YOLO model dialog...")

        filetypes = [
            ("YOLO Models", "*.pt *.onnx"),
            ("PyTorch Models", "*.pt"),
            ("ONNX Models", "*.onnx"),
            ("All files", "*.*")
        ]

        model_path = filedialog.askopenfilename(
            title="Select YOLO Model for Border Detection",
            filetypes=filetypes,
            initialdir=os.path.expanduser("~")
        )

        if model_path:
            try:
                if YOLO_AVAILABLE:
                    from ultralytics import YOLO
                    self.model = YOLO(model_path)
                    self.model_path = model_path

                    # Update UI
                    model_name = os.path.basename(model_path)
                    self.model_status_label.configure(
                        text=f"‚úÖ Loaded: {model_name}",
                        text_color=RevolutionaryTheme.QUANTUM_GREEN
                    )

                    self.status_indicator.configure(
                        text="üü¢ MODEL READY",
                        text_color=RevolutionaryTheme.QUANTUM_GREEN
                    )

                    print(f"‚úÖ YOLO model loaded: {model_name}")
                else:
                    raise ImportError("YOLO not available")

            except Exception as e:
                print(f"‚ùå Model loading error: {e}")
                self.model_status_label.configure(
                    text=f"‚ùå Error: {str(e)[:50]}...",
                    text_color=RevolutionaryTheme.PLASMA_ORANGE
                )

    def load_images_dialog(self):
        """Load images - WORKING VERSION"""
        print("üì∏ Opening image dialog...")

        filetypes = [
            ("All Images", "*.jpg *.jpeg *.png *.tiff *.tif *.bmp"),
            ("JPEG files", "*.jpg *.jpeg"),
            ("PNG files", "*.png"),
            ("TIFF files", "*.tiff *.tif"),
            ("All files", "*.*")
        ]

        filenames = filedialog.askopenfilenames(
            title="Select Card Images for Border Calibration",
            filetypes=filetypes
        )

        if filenames:
            self.image_files = list(filenames)
            self.current_index = 0

            # Load first image
            self.load_current_image()

            # Update counter
            self.update_image_counter()

            print(f"‚úÖ Loaded {len(self.image_files)} images")

    def load_current_image(self):
        """Load the current image for display"""
        if not self.image_files or self.current_index >= len(self.image_files):
            return

        image_path = self.image_files[self.current_index]
        self.current_image_path = image_path

        try:
            # Load with OpenCV
            self.original_image = cv2.imread(image_path)
            if self.original_image is None:
                raise ValueError(f"Could not load image: {image_path}")

            # Display the image
            self.display_current_image()

            # Clear previous annotations
            self.annotations = []
            self.original_predictions = []

            print(f"üì∏ Loaded: {os.path.basename(image_path)}")

        except Exception as e:
            print(f"‚ùå Error loading image: {e}")

    def display_current_image(self):
        """Display the current image CENTERED on canvas"""
        if self.original_image is None:
            return

        # Clear canvas
        self.canvas.delete("all")

        # Convert BGR to RGB
        rgb_image = cv2.cvtColor(self.original_image, cv2.COLOR_BGR2RGB)

        # Apply zoom and rotation
        display_img = self.apply_display_transforms(rgb_image)

        # Convert to PIL and then PhotoImage
        pil_image = Image.fromarray(display_img)
        self.photo = ImageTk.PhotoImage(pil_image)

        # Wait for canvas to be ready
        self.canvas.update_idletasks()
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        if canvas_width <= 1 or canvas_height <= 1:
            # Canvas not ready, try again later
            self.after(100, self.display_current_image)
            return

        # üîß CENTER THE IMAGE
        center_x = canvas_width // 2
        center_y = canvas_height // 2

        # Display image at CENTER
        self.image_item = self.canvas.create_image(
            center_x, center_y,
            image=self.photo,
            anchor="center"
        )

        # Update scroll region to include full image
        img_width = pil_image.width
        img_height = pil_image.height

        scroll_left = center_x - img_width // 2
        scroll_top = center_y - img_height // 2
        scroll_right = center_x + img_width // 2
        scroll_bottom = center_y + img_height // 2

        self.canvas.configure(scrollregion=(scroll_left, scroll_top, scroll_right, scroll_bottom))

    def apply_display_transforms(self, image):
        """Apply zoom and rotation transforms"""
        h, w = image.shape[:2]

        # Apply rotation if needed
        if abs(self.rotation_angle) > 0.01:
            center = (w // 2, h // 2)
            rotation_matrix = cv2.getRotationMatrix2D(center, self.rotation_angle, 1.0)
            image = cv2.warpAffine(image, rotation_matrix, (w, h))

        # Apply zoom
        if self.zoom_level != 1.0:
            new_w = int(w * self.zoom_level)
            new_h = int(h * self.zoom_level)
            image = cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_LANCZOS4)

        return image

    def update_image_counter(self):
        """Update image counter display"""
        if self.image_files:
            counter_text = f"{self.current_index + 1} / {len(self.image_files)}"
            filename = os.path.basename(self.image_files[self.current_index])
            self.image_counter_label.configure(text=f"{counter_text}\n{filename}")
        else:
            self.image_counter_label.configure(text="No images loaded")

    def prev_image(self):
        """Go to previous image"""
        if self.image_files and self.current_index > 0:
            self.current_index -= 1
            self.load_current_image()
            self.update_image_counter()
            print(f"‚óÄ Previous: {self.current_index + 1}/{len(self.image_files)}")

    def next_image(self):
        """Go to next image"""
        if self.image_files and self.current_index < len(self.image_files) - 1:
            self.current_index += 1
            self.load_current_image()
            self.update_image_counter()
            print(f"‚ñ∂ Next: {self.current_index + 1}/{len(self.image_files)}")

    def create_new_dataset(self):
        """Create new dataset"""
        print("üìã Creating new dataset...")

    def save_dataset(self):
        """Save dataset"""
        print("üíæ Saving dataset...")

    def run_revolutionary_detection(self):
        """Run YOLO detection - WORKING VERSION"""
        if not self.model:
            print("‚ùå No model loaded!")
            messagebox.showwarning("Warning", "Please load a YOLO model first")
            return

        if not self.original_image is not None:
            print("‚ùå No image loaded!")
            messagebox.showwarning("Warning", "Please load an image first")
            return

        print("‚ö° Running YOLO detection...")

        try:
            # Run inference
            results = self.model(self.original_image, conf=self.confidence_var.get())

            # Clear previous annotations
            self.annotations = []
            self.original_predictions = []

            # Process results
            for result in results:
                boxes = result.boxes
                if boxes is not None:
                    for box in boxes:
                        # Get detection data
                        x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                        conf = box.conf[0].cpu().numpy()
                        cls = int(box.cls[0].cpu().numpy())

                        # Create annotation
                        label = self.class_names.get(cls, f"class_{cls}")
                        annotation = BorderAnnotation(
                            x1=float(x1), y1=float(y1),
                            x2=float(x2), y2=float(y2),
                            class_id=cls,
                            confidence=float(conf),
                            label=label
                        )

                        self.annotations.append(annotation)
                        self.original_predictions.append(annotation)

            # Update display
            self.draw_annotations()

            print(f"‚úÖ Detection complete: {len(self.annotations)} borders found")

        except Exception as e:
            print(f"‚ùå Detection error: {e}")
            messagebox.showerror("Detection Error", f"YOLO detection failed:\n{str(e)}")

    def draw_annotations(self):
        """PRECISION - Thin lines with small, precise corner handles"""
        if not hasattr(self, 'photo') or not self.annotations:
            return

        # Get original image and apply transforms
        rgb_image = cv2.cvtColor(self.original_image, cv2.COLOR_BGR2RGB)
        display_img = self.apply_display_transforms(rgb_image)
        pil_image = Image.fromarray(display_img)
        draw = ImageDraw.Draw(pil_image)

        for annotation in self.annotations:
            color = self.class_colors.get(annotation.class_id, "#FFFFFF")

            # Convert coordinates for display drawing
            display_x1 = annotation.x1 * self.zoom_level
            display_y1 = annotation.y1 * self.zoom_level
            display_x2 = annotation.x2 * self.zoom_level
            display_y2 = annotation.y2 * self.zoom_level

            # üîß PRECISION: Thin border lines
            line_width = 2 if annotation == self.selected_annotation else 1
            draw.rectangle([display_x1, display_y1, display_x2, display_y2], outline=color, width=line_width)

            # Draw label
            label_text = f"{annotation.label}"
            if annotation.corrected_by_human:
                label_text += " ‚úèÔ∏è"
            else:
                label_text += f" ({annotation.confidence:.2f})"
            draw.text((display_x1, display_y1-25), label_text, fill=color)

            # üîß PRECISION: Small corner handles for selected annotation
            if annotation == self.selected_annotation:
                handle_size = 6  # üîß MUCH SMALLER - was 20, now 6!

                # Get corner positions in DISPLAY coordinates
                left = min(display_x1, display_x2)
                right = max(display_x1, display_x2)
                top = min(display_y1, display_y2)
                bottom = max(display_y1, display_y2)

                corners = [
                    (left, top),     # top-left
                    (right, top),    # top-right
                    (left, bottom),  # bottom-left
                    (right, bottom)  # bottom-right
                ]

                for cx, cy in corners:
                    # üîß PRECISION: Small handles with black outline

                    # Black outline (slightly larger)
                    draw.rectangle(
                        [cx-handle_size-1, cy-handle_size-1, cx+handle_size+1, cy+handle_size+1],
                        outline="#000000", fill="#000000"
                    )

                    # Colored center
                    draw.rectangle(
                        [cx-handle_size, cy-handle_size, cx+handle_size, cy+handle_size],
                        outline=color, fill=color
                    )

                    # Tiny white center dot for ultimate precision
                    draw.rectangle(
                        [cx-1, cy-1, cx+1, cy+1],
                        outline="#FFFFFF", fill="#FFFFFF"
                    )

        # Update canvas
        self.photo = ImageTk.PhotoImage(pil_image)
        self.canvas.itemconfig(self.image_item, image=self.photo)

    def select_border_by_class(self, class_id):
        """Select border by class - WORKING VERSION"""
        print(f"üéØ Selecting border class: {class_id}")

        # Find annotation with matching class
        for annotation in self.annotations:
            if annotation.class_id == class_id:
                self.selected_annotation = annotation
                self.update_selected_info()
                self.draw_annotations()  # Redraw with selection highlight
                print(f"‚úÖ Selected {annotation.label} border")
                return

        print(f"‚ùå No {self.class_names.get(class_id, f'class_{class_id}')} border found")

    def update_rotation(self, value):
        """Update rotation - WORKING VERSION"""
        self.rotation_angle = float(value)
        print(f"üîÑ Rotation: {self.rotation_angle:.1f}¬∞")

        # Redisplay image with rotation
        if self.original_image is not None:
            self.display_current_image()

    def reset_rotation(self):
        """Reset rotation - WORKING VERSION"""
        self.rotation_angle = 0.0
        self.rotation_var.set(0.0)

        # Redisplay image
        if self.original_image is not None:
            self.display_current_image()

        print("‚Ü∫ Rotation reset to 0¬∞")
    def set_zoom(self, zoom_level):
        """Set zoom level - WORKING VERSION"""
        print(f"üîç Setting zoom to: {zoom_level}")
        self.zoom_level = zoom_level

        # Redisplay image with new zoom
        if self.original_image is not None:
            self.display_current_image()

        print(f"‚úÖ Zoom set to {int(zoom_level*100)}%")

    def fit_to_window(self):
        """Fit image to window - WORKING VERSION"""
        if self.original_image is None:
            return

        # Get canvas size
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        if canvas_width <= 1 or canvas_height <= 1:
            return

        # Get image size
        img_height, img_width = self.original_image.shape[:2]

        # Calculate fit zoom
        zoom_x = (canvas_width - 40) / img_width  # Leave 40px margin
        zoom_y = (canvas_height - 40) / img_height
        fit_zoom = min(zoom_x, zoom_y, 1.0)  # Don't zoom beyond 100%

        self.set_zoom(fit_zoom)
        print(f"üìê Fit to window: {int(fit_zoom*100)}%")

    def update_selected_info(self):
        """Update selected border info display"""
        if self.selected_annotation:
            info_text = f"üìç Selected: {self.selected_annotation.label}\n"
            info_text += f"üìä Confidence: {self.selected_annotation.confidence:.3f}\n"
            info_text += f"üìê Size: {int(self.selected_annotation.width)} x {int(self.selected_annotation.height)}\n"

            if self.selected_annotation.corrected_by_human:
                info_text += f"‚úèÔ∏è Human corrected"
            else:
                info_text += f"ü§ñ AI detected"

            self.selected_info.configure(
                text=info_text,
                text_color=self.class_colors.get(self.selected_annotation.class_id, RevolutionaryTheme.GHOST_WHITE)
            )
        else:
            self.selected_info.configure(
                text="No border selected\n\nClick a border or use selection buttons",
                text_color=RevolutionaryTheme.GHOST_WHITE
            )

    def set_sticky_selection(self, class_id):
        """Set sticky selection mode for specific border class"""
        self.sticky_selection_mode = True
        self.sticky_class_id = class_id

        # Update button appearance to show active state
        if class_id == 0:  # Outer
            self.outer_btn.configure(
                fg_color=RevolutionaryTheme.PLASMA_BLUE,
                text="üîµ OUTER (ACTIVE)"
            )
            self.inner_btn.configure(
                fg_color=("gray20", "gray20"),
                text="üü¢ INNER"
            )
        else:  # Inner
            self.inner_btn.configure(
                fg_color=RevolutionaryTheme.QUANTUM_GREEN,
                text="üü¢ INNER (ACTIVE)"
            )
            self.outer_btn.configure(
                fg_color=("gray20", "gray20"),
                text="üîµ OUTER"
            )

        # Select the border
        self.select_border_by_class(class_id)
        print(f"üéØ STICKY SELECTION: {self.class_names.get(class_id)} borders only")

    def stop_sticky_selection(self):
        """Stop sticky selection mode"""
        self.sticky_selection_mode = False
        self.sticky_class_id = None

        # Reset button appearance
        self.outer_btn.configure(
            fg_color=("gray20", "gray20"),
            text="üîµ OUTER"
        )
        self.inner_btn.configure(
            fg_color=("gray20", "gray20"),
            text="üü¢ INNER"
        )

        print("‚èπÔ∏è Sticky selection stopped - free selection mode")

    def send_to_photometric_stereo(self):
        """Send to photometric stereo"""
        print("üî¨ Sending to photometric stereo...")
        if self.photometric_callback:
            # Example data structure
            calibration_data = {
                'calibrated_borders': [],
                'calibration_metadata': {
                    'human_corrections': 0,
                    'total_borders': 0
                }
            }
            self.photometric_callback(calibration_data)

    def on_canvas_click(self, event):
        """PRECISION - Updated for smaller handles"""
        print(f"\nüñ±Ô∏è === PRECISION CLICK ===")

        if not self.annotations:
            print("‚ùå No annotations to click")
            return

        # Get click position
        canvas_x, canvas_y = event.x, event.y
        img_x, img_y = self.canvas_to_image_coords(canvas_x, canvas_y)

        print(f"üñ±Ô∏è Precision click: Canvas({canvas_x}, {canvas_y}) -> Image({img_x:.1f}, {img_y:.1f})")

        # Reset drag states
        self.dragging_corner = None
        self.dragging_border = False

        # Find target annotation
        target_annotation = None
        if self.sticky_selection_mode and self.sticky_class_id is not None:
            for annotation in self.annotations:
                if annotation.class_id == self.sticky_class_id:
                    target_annotation = annotation
                    break
        else:
            for annotation in self.annotations:
                if annotation.contains_point(img_x, img_y):
                    target_annotation = annotation
                    break

        if not target_annotation:
            print("‚ùå No annotation found")
            self.selected_annotation = None
            self.update_selected_info()
            self.draw_annotations()
            return

        self.selected_annotation = target_annotation
        print(f"üìç Selected: {target_annotation.label}")

        # üîß PRECISION: Check corners with smaller tolerance
        corner_hit = target_annotation.get_corner_handle(img_x, img_y, handle_size=15)  # Smaller hit area

        if corner_hit:
            self.dragging_corner = corner_hit
            self.dragging_border = False
            self.last_mouse_x = img_x
            self.last_mouse_y = img_y
            print(f"üéØ PRECISION CORNER DRAG: {corner_hit}")
        elif target_annotation.contains_point(img_x, img_y):
            self.dragging_border = True
            self.dragging_corner = None
            self.last_mouse_x = img_x
            self.last_mouse_y = img_y
            print(f"üéØ BORDER MOVE MODE")

        self.update_selected_info()
        self.draw_annotations()
        print(f"üñ±Ô∏è === END PRECISION CLICK ===\n")

    def on_canvas_drag(self, event):
        """WORKING canvas drag handler"""
        if not self.selected_annotation:
            return

        # Get current position
        current_x, current_y = self.canvas_to_image_coords(event.x, event.y)

        if self.dragging_corner:
            print(f"üîß DRAGGING CORNER: {self.dragging_corner} to ({current_x:.1f}, {current_y:.1f})")

            # Apply corner movement
            if hasattr(self.selected_annotation, 'move_corner'):
                self.selected_annotation.move_corner(self.dragging_corner, current_x, current_y)
                print(f"‚úÖ Corner moved successfully")
            else:
                print(f"‚ùå move_corner method missing!")

            # Redraw immediately
            self.draw_annotations()

        elif self.dragging_border:
            print(f"üîß DRAGGING BORDER: from ({self.last_mouse_x:.1f}, {self.last_mouse_y:.1f}) to ({current_x:.1f}, {current_y:.1f})")

            # Calculate movement
            dx = current_x - self.last_mouse_x
            dy = current_y - self.last_mouse_y

            # Apply border movement
            if hasattr(self.selected_annotation, 'move_border'):
                self.selected_annotation.move_border(dx, dy)
                print(f"‚úÖ Border moved by ({dx:.1f}, {dy:.1f})")
            else:
                print(f"‚ùå move_border method missing!")

            # Update last position
            self.last_mouse_x = current_x
            self.last_mouse_y = current_y

            # Redraw
            self.draw_annotations()

    def on_canvas_release(self, event):
        """Handle canvas release - FIXED state cleanup"""
        if self.dragging_corner or self.dragging_border:
            print("‚úÖ Drag operation completed")

            # Mark as human corrected
            if self.selected_annotation:
                self.selected_annotation.corrected_by_human = True
                self.selected_annotation.correction_timestamp = datetime.now().isoformat()
                print(f"‚úèÔ∏è Marked {self.selected_annotation.label} as human corrected")

        # Clear drag states
        self.dragging_corner = None
        self.dragging_border = False

    def on_canvas_motion(self, event):
        """Handle canvas motion for cursor changes"""
        if not self.annotations or not self.selected_annotation:
            self.canvas.configure(cursor="")
            return

        # Get mouse position
        mouse_x, mouse_y = self.canvas_to_image_coords(event.x, event.y)

        # Check if hovering over a corner handle
        corner = self.selected_annotation.get_corner_handle(mouse_x, mouse_y, handle_size=20)

        if corner:
            # Show resize cursor for corners
            cursor_map = {
                'top_left': 'top_left_corner',
                'top_right': 'top_right_corner',
                'bottom_left': 'bottom_left_corner',
                'bottom_right': 'bottom_right_corner'
            }
            self.canvas.configure(cursor=cursor_map.get(corner, 'sizing'))
        elif self.selected_annotation.contains_point(mouse_x, mouse_y):
            # Show move cursor for border interior
            self.canvas.configure(cursor='fleur')
        else:
            # Default cursor
            self.canvas.configure(cursor="")

    def canvas_to_image_coords(self, canvas_x, canvas_y):
        """DEBUGGED - Canvas to image coordinate conversion"""
        print(f"üîÑ Converting canvas ({canvas_x}, {canvas_y})")

        if not hasattr(self, 'image_item') or not self.image_item:
            print(f"‚ùå No image_item available")
            return canvas_x, canvas_y

        try:
            # Get canvas scroll position
            canvas_scroll_x = self.canvas.canvasx(0)
            canvas_scroll_y = self.canvas.canvasy(0)

            # Convert canvas coordinates to scrolled coordinates
            scrolled_x = self.canvas.canvasx(canvas_x)
            scrolled_y = self.canvas.canvasy(canvas_y)

            print(f"üìú Scroll offset: ({canvas_scroll_x:.1f}, {canvas_scroll_y:.1f})")
            print(f"üìç Scrolled coords: ({scrolled_x:.1f}, {scrolled_y:.1f})")

            # Get image bbox in canvas coordinates
            bbox = self.canvas.bbox(self.image_item)
            if not bbox:
                print(f"‚ùå No image bbox")
                return canvas_x, canvas_y

            img_left, img_top, img_right, img_bottom = bbox
            print(f"üì¶ Image bbox: ({img_left}, {img_top}) to ({img_right}, {img_bottom})")

            # Convert to image-relative coordinates
            rel_x = scrolled_x - img_left
            rel_y = scrolled_y - img_top

            print(f"üìê Relative: ({rel_x:.1f}, {rel_y:.1f})")

            # Convert from display coordinates to original image coordinates
            img_x = rel_x / self.zoom_level
            img_y = rel_y / self.zoom_level

            print(f"‚úÖ FINAL: Canvas({canvas_x}, {canvas_y}) -> Image({img_x:.1f}, {img_y:.1f}) [zoom: {self.zoom_level:.2f}]")
            return img_x, img_y

        except Exception as e:
            print(f"‚ùå Conversion error: {e}")
            return canvas_x, canvas_y

    def on_key_press(self, event):
        """Handle keyboard shortcuts"""
        key = event.keysym.lower()

        if key == 'delete' and self.selected_annotation:
            # Delete selected annotation
            self.annotations.remove(self.selected_annotation)
            self.selected_annotation = None
            self.update_selected_info()
            self.draw_annotations()
            print("üóëÔ∏è Deleted selected border")

        elif key == '1':
            # Select outer border
            self.select_border_by_class(0)

        elif key == '2':
            # Select inner border
            self.select_border_by_class(1)

        elif key == 'r':
            # Reset rotation
            self.reset_rotation()

        elif key == 'f':
            # Fit to window
            self.fit_to_window()

# Integration function for the revolutionary shell
def create_border_calibration_module(parent, command_callback=None, photometric_callback=None):
    """Create and return the revolutionary border calibration module"""
    return RevolutionaryBorderCalibration(parent, command_callback, photometric_callback)

if __name__ == "__main__":
    # Test the revolutionary border calibration module
    print("üéØ Testing Revolutionary Border Calibration Module")

    root = ctk.CTk()
    root.title("Revolutionary Border Calibration - Test")
    root.geometry("1600x1000")

    # Apply revolutionary theme
    ctk.set_appearance_mode("dark")

    # Create module
    calibration_module = RevolutionaryBorderCalibration(root)
    calibration_module.pack(fill="both", expand=True)

    root.mainloop()
